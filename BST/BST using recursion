#include <iostream>
using namespace std;

class BstNode {

private:
    int data;
    BstNode* left;
    BstNode* right;
    BstNode* root = NULL;
    int count = 0;

    // recursive function that insert node to its right poistion
    BstNode* insert_node(BstNode* root, BstNode* node) {
        if (root == NULL) {
            root = node;
        }
        else if (node->data <= root->data) {
            root->left = insert_node(root->left, node);
        }
        else {
            root->right = insert_node(root->right, node);
        }
        return root;
    }
//recursive function that find the minimum element in the treea
    int min(BstNode* root)
    {
        if (root == NULL) { return 0; }
        else if (root->left == NULL)
            return root->data;
        return min(root->left);
    }
    
//recursive function that find the maximum element in the tree    
    int max(BstNode* root)
    {
        if (root == NULL) { return 0; }
        else if (root->right == NULL)
            return root->data;
        return min(root->right);
    }
//recursive function that returns whether the element in the tree or not
    bool find(BstNode* root,int data)
    {
        if (root == NULL)return 0;
        else if (root->data == data)return true;
        else if (data <= root->data) return find(root->left, data);
        else return find(root->right, data);
    }
    /*return -1 if we in the leaf because the height of the leaf node is 0 so 
    we return -1 for left and -1 for right -> max(-1,-1)+1 -> 0 so for the 
    leaf nodes we return 0 as the height of that node*/
    int find_height(BstNode* root)
    {
        if (root == NULL)
            return -1;
        else return max(find_height(root->left), find_height(root->right)) + 1;

    }
    public:
    /* each call to the function we can either explicitly set the root pointer 
    * to point to the right node ,by set the return value equal to the left or 
    * right pointer ,or implicitly do that by pass the pointer by refrence so it 
    * get changed automatically each time we modify it  
    */
    /*
    void insert_node(BstNode*& root,BstNode*& node) 
    {
        if (root == NULL) {
            root = node;
        }
        else if (node->data <= root->data) {
           insert_node(root->left,node);
        }
        else {
            insert_node(root->right, node);
        }
    }
    */
   
    void insert(int data)
    {
        BstNode* node = new BstNode();
        node->data = data;
        node->right = NULL;
        node->left = NULL;
        root=insert_node(root,node);
        count++;
    }
    bool search(int data)
    {
        bool res;
        res=find(root, data);
        return res;
    }
      int height()
    {
         int res=find_height(root);
        return res;
    }

    int size() { return count;}
   
    int min_elements() { return min(root); }
    int max_elements() { return max(root); }
    int num_edges() { return count - 1; }
    int num_nodes() { return count; }

};


int main()
{
    
    BstNode b;
    b.insert(50);
    b.insert(30);
    b.insert(26);
    b.insert(11);
    b.insert(10);

}
