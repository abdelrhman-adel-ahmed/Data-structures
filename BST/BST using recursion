#include <iostream>
using namespace std;

class BstNode {

private:
    int data;
    BstNode* left;
    BstNode* right;
    BstNode* root = NULL;
    int count = 0;

    // recursive function that insert node to its right poistion
    BstNode* insert_node(BstNode* root, BstNode* node) {
        if (root == NULL) {
            root = node;
        }
        else if (node->data <= root->data) {
            root->left = insert_node(root->left, node);
        }
        else {
            root->right = insert_node(root->right, node);
        }
        return root;
    }
//recursive function that find the minimum element in the treea
    int min(BstNode* root)
    {
        if (root == NULL) { return 0; }
        else if (root->left == NULL)
            return root->data;
        return min(root->left);
    }
    
//recursive function that find the maximum element in the tree    
    int max(BstNode* root)
    {
        if (root == NULL) { return 0; }
        else if (root->right == NULL)
            return root->data;
        return min(root->right);
    }
//recursive function that returns whether the element in the tree or not
   bool recursive_search(BstNode* root,int data)
    {
        if (root == NULL) return false;
        else if (root->data == data) return true;
        else if (data > root->data)
           return recursive_search(root->right, data);
        else
           return recursive_search(root->left, data);
        
    }

    /*return -1 if we in the leaf because the height of the leaf node is 0 so 
    we return -1 for left and -1 for right -> max(-1,-1)+1 -> 0 so for the 
    leaf nodes we return 0 as the height of that node*/
    int find_height(BstNode* root)
    {
        if (root == NULL)
            return -1;
        else return max(find_height(root->left), find_height(root->right)) + 1;

    }
     BstNode* get_address(BstNode* root, int data)
    {
        if (root == NULL)return root;
        else if (data == root->data)return root;
        else if (data <= root->data)
            return get_address(root->left, data);
        else
            return get_address(root->right,data);
    }
    
    void bfs_preorder(BstNode* root)
    {
        if (root == NULL)
            return;
        cout << root->data << " ";
        bfs_preorder(root->left);
        bfs_preorder(root->right);
    }
    /* <left><root><right>
    * 1-we go left tell we hit the leaf of that sub tree
    * 2-then print the root of that sub tree
    * 3-then go right ,and then repeate go left again tell we hit a leaf print ...
    */
    void bfs_inorder(BstNode* root)
    {
        if (root == NULL)
            return;
        bfs_inorder(root->left);
        cout << root->data << " ";
        bfs_inorder(root->right);
    }
    /* <left><right><root>
    */
    void bfs_postorder(BstNode* root)
    {
        if (root == NULL)
            return;
        bfs_postorder(root->left);
        bfs_postorder(root->right);
        cout << root->data << " ";
    }
    
    
    public:
    /* each call to the function we can either explicitly set the root pointer 
    * to point to the right node ,by set the return value equal to the left or 
    * right pointer ,or implicitly do that by pass the pointer by refrence so it 
    * get changed automatically each time we modify it  
    */
    /*
    void insert_node(BstNode*& root,BstNode*& node) 
    {
        if (root == NULL) {
            root = node;
        }
        else if (node->data <= root->data) {
           insert_node(root->left,node);
        }
        else {
            insert_node(root->right, node);
        }
    }
    */
   
    void insert(int data)
    {
        BstNode* node = new BstNode();
        node->data = data;
        node->right = NULL;
        node->left = NULL;
        root=insert_node(root,node);
        count++;
    }
    bool search(int data)
    {
        bool res;
        res=find(root, data);
        return res;
    }
   BstNode* get_root() { return root; }
    void insert(int data)
    {
        BstNode* node = new BstNode();
        node->data = data;
        node->right = NULL;
        node->left = NULL;
        insert_node(node);
        count++;
    }
      BstNode* get_node_address(int data)
    {
        return get_address(root, data);
    }
    bool search(int data)
    {
        bool res = recursive_search(root, data);
        return res;
    }

    int size() { return count;}
   
     int min_elements()
    {
        BstNode* current = root;
        if (root == NULL) return -1;
        while (current->left != NULL)
        {
            current = current->left;
        }
        return current->data;
    }
    int max_elements()
    {
        BstNode* current = root;
        if (root == NULL) return -1;
        while (current->right != NULL)
        {
            current = current->right;
        }
        return current->data;
    }
    int num_edges() { return count - 1; }
    int num_nodes() { return count; }
    int tree_height()
    {
         int res=find_height(root);
        return res;
    }
  
    int node_height(int data)
    {
        BstNode* node=NULL;
        node = get_node_address(data);
        int height = find_height(node);
        return height;
    }
    void BFS_traverse()
    {
        if (root == NULL)
        {
            cout << "shit is real" << endl;
            return;
        }
        BstNode* temp = root;   
        int res = 0;
        q.push(temp);
        while (!(q.empty()))
        {
           // cout << q.front()->data<<" ";
           // if (q.front()->left != NULL)
           //     q.push(q.front()->left);
           // if (q.front()->right != NULL)
           //     q.push(q.front()->right);
           // q.pop();
        //you can make a current pointer and avoid calling front extra two times
            BstNode* current = q.front();
            cout << current->data<<" ";
            if (current->left != NULL)
                q.push(current->left);
            if (current->right != NULL)
                q.push(current->right);
            q.pop();

        }
        cout << endl;
    }
    void DFS_preorder()  { bfs_preorder(root);  cout << endl;  }
    void DFS_inorder()   { bfs_inorder(root);  cout << endl;  }
    void DFS_postorder() { bfs_postorder(root); cout << endl;  }

};


int main()
{
    
    BstNode b;
    b.insert(50);
    b.insert(30);
    b.insert(26);
    b.insert(11);
    b.insert(10);

}
